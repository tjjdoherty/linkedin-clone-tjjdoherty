import { firestore } from '../firebaseConfig';
import { addDoc, collection, onSnapshot, doc, updateDoc, query, where, setDoc, deleteDoc } from 'firebase/firestore';
import { toast } from "react-toastify";

// adding the object as well as postsRef because object may include images, video, or emoji files in addition to just text in the status update. dbRef became postsRef

// purpose of PostStatusData and postUserData - add items to the database
// purpose of getStatus and getCurrentUser - onSnapshot will listen for changes when new posts are added or new users are signed up. 
// As soon as that happens the setAllStatus/setCurrentUser will update

// these methods and currentUser starts being passed down as props / a state, from layouts 
// GET CURRENT USER takes SET CURRENT USER from LAYOUTS page. This is where currentUser starts being passed down as props through profile/Home --> profileComponent/HomeComponent

// IMPORTANT!!!!! every post now logs the User ID of the user who wrote it, so you can get to the profile page. 
// BUt it's logging users.id (the firebase generated one) NOT the getUniqueID one. Be careful if this is important later on...

let postsRef = collection(firestore, "posts");
let userRef = collection(firestore, "users");
let likeRef = collection(firestore, "likes");
let commentsRef = collection(firestore, "comments");
let connectionRef = collection(firestore, "connections");

export const PostStatusData = (object) => {
    addDoc(postsRef, object)
        .then((response) => {
            toast.success("Posted!");
        })
        .catch((error) => {
            console.log(error);
        })
};

// use of on Snapshot - now when we post a status with the postUpdate recent lines of code, it is rendered immediately

export const getStatus = (setAllStatus) => {
    onSnapshot(postsRef, (response) => {
        setAllStatus(
            response.docs.map((docs) => {
                return {...docs.data(), id: docs.id}
            })
        )
    })
};

export const getAllUsers = (setAllUsers) => {
    onSnapshot(userRef, (response) => {
        setAllUsers(
            response.docs.map((docs) => {
                return {...docs.data(), id: docs.id}
            })
        )
    })
}

export const getSingleStatus = (setAllStatus, id) => {
    const singlePostQuery = query(postsRef, where("userID", "==", id));
    onSnapshot(singlePostQuery, (response) => {
        setAllStatus(
            response.docs.map((docs) => {
                return { ...docs.data(), id: docs.id };
            })
        );
    });
};

export const getSingleUser = (setCurrentUser, email) => {
    const singleUserQuery = query(userRef, where("email", "==", email));
    onSnapshot(singleUserQuery, (response) => {
        setCurrentUser(
            response.docs.map((docs) => {
                return { ...docs.data(), id: docs.id };
            })[0]
        );
    });
};

export const postUserData = (object) => {
    addDoc(userRef, object)
    .then(() => {})
    .catch((err) => {
        console.log(err);
    });
};

// line 47 localStorage getItem because in RegisterComponent, we did localStorage setItem userEmail
//setCurrentUser is not returning the email address, it's returning the full user object whose email address in local storage matches the email in the user object
// userID (line 58) is where we transform the autogenerated Firebase ID for a user into our own variable userID

export const getCurrentUser = (setCurrentUser) => {
    let currEmail = localStorage.getItem('userEmail')

    onSnapshot(userRef, (response) => {
        setCurrentUser(
            response.docs
            .map((docs) => {
                return { ...docs.data(), userID: docs.id }
            })
            .filter((item) => {
                return item.email === currEmail;
            })[0]
        )
    })
}

export const editProfile = (userID, payload) => {
    let userToEdit = doc(userRef, userID)

    updateDoc(userToEdit, payload)
    .then(() => {
        toast.success("Successfully Updated Profile Details");
    })
    .catch((err) => {
        console.log(err);
    });

}

// likePost has created a likes table (similar to posts and users) which captures postId and userId,

// liked parameter - if the post is already liked and you click again to UN-LIKE we delete the like from the database (line 113)

export const likePost = (userId, postId, liked) => {
    try {
        let docToLike = doc(likeRef, `${userId}_${postId}`);
    if (liked) {
        deleteDoc(docToLike);
    }
    else {
        setDoc(docToLike, { userId, postId })
    }
     
    }
    catch (err) {
        console.log(err)
    }
}

export const getLikesByUser = (userId, postId, setLikesCount, setLiked) => {
    try {
        let likeQuery = query(likeRef, where('postId', '==', postId))

        onSnapshot(likeQuery, (response) => {
            let likes = response.docs.map((doc) => doc.data())
            let likesCount = likes.length;

            const isLiked = likes.some((like) => like.userId === userId)

            setLikesCount(likesCount);
            setLiked(isLiked);
        });
    } catch (err) {
        console.log(err);
    }
};

export const postComment = (postId, comment, timeStamp, name) => {
    try {
        addDoc(commentsRef, {
            postId,
            comment,
            timeStamp,
            name
        })
    }
    catch (err) {
        console.log(err);
    }
}

// this below query is checking if the postId in the document in the database collection is the same as the postId for each post
// because each post has a unique postId it will only match with one comment - the comments will appear once for their specific post and that's it.
// where() in query takes 3 arguments, the first is the field INSIDE the database. the second is the relation e.g. == and third is the comparison e.g. postId we're matching 

export const getComments = (postId, setComments) => {
    try {
        let singlePostQuery = query(commentsRef, where("postId", "==", postId))

        onSnapshot(singlePostQuery, (response) => {
            const comments = response.docs.map((doc) => {
                return {
                    id: doc.id,
                    ...doc.data(),
                };
            });
            setComments(comments);
        });
    }
    catch (err) {
        console.log(err);
    }

}

export const updatePost = (id, status, postImage ) => {
    let docToUpdate = doc(postsRef, id);

    try {
        updateDoc(docToUpdate, { status, postImage })
        .then(() => {
            toast.success("Post has been updated.");
        })

    } catch(err) {
        console.log(err);
    }
}

export const deletePost = (id) => {
    let docToDelete = doc(postsRef, id);

    try {
        deleteDoc(docToDelete)
        .then(() => {
            toast.success("Post has been deleted.");
        })

    } catch(err) {
        console.log(err);

    }
}

export const addConnection = (userID, targetID) => {
    try {
        let connectionToAdd = doc(connectionRef, `${userID}_${targetID}`);
    
        setDoc(connectionToAdd, { userID, targetID });

        toast.success("Connection request sent");

    }
    
    catch (err) {
        console.log(err);
    }
}

export const getConnections = (userID, targetID, setIsConnected) => {
    try {
        let connectionQuery = query(connectionRef, where('targetID', '==', targetID))

        onSnapshot(connectionQuery, (response) => {
            let connections = response.docs.map((doc) => doc.data())

            const isConnected = connections.some((connection) => connection.userID === userID)

            setIsConnected(isConnected);
        });
    } catch (err) {
        console.log(err);
    }
};